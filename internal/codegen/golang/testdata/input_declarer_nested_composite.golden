// FooType represents the Postgres composite type "foo_type".
type FooType struct {
	Alpha pgtype.Text `json:"alpha"`
}

// SomeTable represents the Postgres composite type "some_table".
type SomeTable struct {
	Foo    FooType     `json:"foo"`
	BarBaz pgtype.Text `json:"bar_baz"`
}

// assignFooTypeComposite returns all composite fields for the Postgres
// 'foo_type' composite type as a slice of interface{} for use with the
// pgtype.Value Set method.
func assignFooTypeComposite(p FooType) []interface{} {
	return []interface{}{
		p.Alpha,
	}
}

// newFooTypeDecoder creates a new decoder for the Postgres 'foo_type' composite type.
func newFooTypeDecoder() pgtype.ValueTranscoder {
	return newCompositeType(
		"foo_type",
		[]string{"alpha"},
		&nil,
	)
}

// newSomeTableDecoder creates a new decoder for the Postgres 'some_table' composite type.
func newSomeTableDecoder() pgtype.ValueTranscoder {
	return newCompositeType(
		"some_table",
		[]string{"foo", "bar_baz"},
		newFooTypeDecoder(),
		&nil,
	)
}

// newSomeTableEncoder creates a new encoder for the Postgres 'some_table' composite type query params.
func newSomeTableEncoder(p SomeTable) textEncoder {
	dec := newSomeTableDecoder()
	dec.Set([]interface{}{
		assignFooTypeComposite(p.Foo),
		p.BarBaz,
	})
	return textEncoder{ValueTranscoder: dec}
}

// ignoredOID means we don't know or care about the OID for a type. This is okay
// because pgx only uses the OID to encode values and lookup a decoder. We only
// use ignoredOID for decoding and we always specify a concrete decoder for scan
// methods.
const ignoredOID = 0

// textEncoder wraps a pgtype.ValueTranscoder and sets the preferred encoding
// format to text instead binary (the default). pggen must use the text format
// because the Postgres binary format requires the type OID but pggen doesn't
// necessarily know the OIDs of the types, hence ignoredOID.
type textEncoder struct {
	pgtype.ValueTranscoder
}

// PreferredParamFormat implements pgtype.ParamFormatPreferrer.
func (t textEncoder) PreferredParamFormat() int16 { return pgtype.TextFormatCode }

func newCompositeType(name string, fieldNames []string, vals ...pgtype.ValueTranscoder) *pgtype.CompositeType {
	fields := make([]pgtype.CompositeTypeField, len(fieldNames))
	for i, name := range fieldNames {
		fields[i] = pgtype.CompositeTypeField{Name: name, OID: ignoredOID}
	}
	// Okay to ignore error because it's only thrown when the number of field
	// names does not equal the number of ValueTranscoders.
	rowType, _ := pgtype.NewCompositeTypeValues(name, fields, vals)
	return rowType
}